Labs link: https://github.com/mikesiko/PracticalMalwareAnalysis-Labs

## Chapter 0 - Malware Analysis Primer

- Malware Analysis can be used to create host-based and network signatures.
  - Host-based signatures are used to detect malicious code on victim computers.
  They identify the behavior of the virus (what it does) and not its
  characteristics.
  - Network signatures are used to detect malicious code by monitoring the
  network

### Techniques

- **Basic static analysis**: Examine the file without viewing instructions
- **Basic dynamic analyis**: Executes the file and see what it does
- **Advanced static analysis**: Use a disassembler to see what the progam really do
- **Advanced dynamic analysis**: Use a debugger to see the internal state of the
program during execution

### Types of malware

- **Backdoor**: Allow an attacker to easily access the system
- **Botnet**: Like a backdoor but all machines infected with the same botnet will
receive the same instructions from the attacker
- **Downloader**: Download and install additional malicious code: First step
- **Information** stealing malware
- **Launcher**: Used to launch other malicious code
- **Rootkit**: Used to hide other malicious code
- **Scareware**: Used to scare the user and make it buy some protection
- **Worm or virus**: Malicious code that can infect additional machines

# Part 1 - Basic Analysis

## Chapter 1 - Basic Static Techniques

### 1 First step: Antivirus Scanning
https://www.virustotal.com/
### 2 Hashing: Fingerprint
MD5 often used
### 3 Strings analysis
### 4 Packed and Obfuscated Malware
- Techniques used to make static analysis harder
- Packed: susbset of obfuscated code, consist of compressing the program so it's
hard to analyze
- Obfuscated code contains only a few strings. But often contains `LoadLibrary`
and `GetProcAddress` strings

#### Packing files
A packed progam contains two parts:
- Wrapper program: not compressed, used to decompress and run the rest of the
program
- Packed executable: core of the program, compressed and contains no strings or
any information

A static analysis of a packed program can only be made on the wrapper program. 

#### Detecting packers with PEiD
Running PEiD on a malicious program allow to detect which packer have been used.

Packer example: **UPX**

`upx -d PackedProgram.exe`

### 5 Portable Executable (PE)
File format used on Windows for almost all executable code.

Sections:
- `.text` : Contains code
- `.data` : Global data accessed by the program
- `.rdata` : Read only data
- `.idata` : Sometimes contains imported functions. If not presents, imported
functions are in `.rdata`
- `.edata` : Same with exported functions
- `.pdata` : Only present on x64. Contains exception handling informations
- `.rsrc` : Resources like icons, images, strings...
- `.reloc` : Information about relocation of libraries

#### PEView
Show important informations about PE headers.
- IMAGE_FILE_HEADER: Contains basic informations like TimeDateStamp (build time)
- For each section, IMAGE_SECTION_HEADER contains its size.
  - VirtualSize is the size in memory
  - Size of raw data is the size on the disk
A packed program will habe higher VirtualSize that Size of raw data.

### 6 Linked Libraries and Functions
- **Imports**: external functions used by the program. Reveal a lot of informations
about its behavior.
- **Static Linking**: The external code is copied inside the executable. Hard to
differentiate external code from malware code.
- **Runtime Linking**: Often used with malicious programs. The executable connects to
libraries at runtime when needed.
  - On windows, `LoadLibrary`, `GetProcAddress`, `LdrGetProcAddress`, `LdrLoadDll`
  are functions used to load external code at runtime that are not registered in
  PE headers
- **Dyanmic Linking**: Most commonly used linking technique. The PE header contains
a list of external functions used by the application. The program loader link
to them when the program is loaded.

- **Dependency Walker**: Allow to list imported functions.
  - A function can be imported by name or by ordinal. Importing by ordinal makes
  it harder to determine which functions are imported.
  - **Dependency Walker** list all DLLs used by the program. For each DLL, it
  shows the imported functions (by name or ordinal) and list all available
  functions in the DLL.

- **Common DLLs**
  - Kernel32.dll : Memory management, process creation, files...
  - Advapi32.dll : Provide access to registry and service manager
  - User32.dll : GUI
  - Gdi32.dll : Graphics
  - Ntdll.dll : Interface with windows kernel. Normally not directly used by
    app. Used by Kernel32.dll
  - WSock32.dll, Ws2_32.dll : Network access
  - Wininet.dll : High level network access (FTP, HTTP...)

- **Exported functions**: Normally, exported functions have a clear name
(ServiceMain is the main of windows service) but malicious program can rename
its exported functions.

# Tools
#### WinMD5
- Link: http://www.winmd5.com/
- Description: GUI for calculating MD5 of multiple files
#### Strings
- Link: https://docs.microsoft.com/en-us/sysinternals/downloads/strings
- Description: Used to display strings in exe file
- Usage: `strings Program.exe`
#### PEiD
- Link: https://www.aldeid.com/wiki/PEiD
- Description: Used to detect if a progam is packed and wich packer it uses
#### UPX
- Link: https://github.com/upx/upx
- Description: Packer/Unpacker of executable code
- Usage: `upx -d PackedProgram.exe`
#### Dependency Walker
- Link: http://www.dependencywalker.com/
- Description: List dynamically linked functions

#### PEview
- Link: https://www.aldeid.com/wiki/PEView
- Description: Examine the content of a PE file

#### PEBrowser
- Link: http://www.smidgeonsoft.prohosting.com/
- Description: Alternative to PEView

#### ResourceHacker
- Link: http://www.angusj.com/resourcehacker/
- Description: Browse and edit .rsrc section